[{"title":"Obsidian基础使用方法","path":"/2024/10/25/Obsidian基础使用方法/","content":"心路历程“黑曜石”好酷的名字 —&gt; 顺藤摸瓜到Obsidian —&gt; 发现它是一个记笔记软件 —&gt; 突然想起自己根本不记笔记 —&gt; 那就创造需求！ 为什么用ObsidianObsidian 是我用过的第一个记笔记软件，对于像我这种没有做笔记习惯的人来说，软件可玩性的重要程度要远远大于笔记本身，使用者完全可以把它当作一个集笔记记录、语言学习、日程管理、制图等于一体的多功能软件。为了更好地使用它，我去了解了卡片笔记法，还看了其他人对Obsidian的自用安排设计，于是站在前人的肩膀上我也开启了自己的想法构建之旅，这让之前任由思维发散的我想大声感慨一句：啊，我也终于可以 get myself together了！ 基本语法链接Obsidian核心功能之一是双向链接，并且可以根据建立的链接生成关系图谱，所有的链接最后都会组成一个圈，让看似毫无关联的事物产生联系。虽然这些联系是由自己创造的，但添加#hashtag的时候可以下拉选择之前创建的标签，所以并不算太复杂。 我觉得这个功能让人下意识地去思考、安排每篇笔记所处的位置，而不是单纯地丢下一堆从各处搜刮来的信息就不管了。 具体的高阶用法我也还在摸索中，以下是几个常用创建链接的语法： 链接到某一篇笔记：[[ ]] 链接到某一篇笔记中的某个标题：[[ # ]] 链接到某一篇笔记中的某个段落（块）：[[ # ^ ]] 为链接创建定义（关键词）：[[ | 关键词]] 链接到外部文件如印象笔记：[关键词]（链接） markdown语法Obsidian支持Markdown语法，界面看起来简洁干净。 Markdown详细用法介绍–&gt;Markdown是什么？ # 大标题（注意要打空格） ## 中标题 ### 小标题 **强调粗体加深** &gt; 引用文字 [这里写超链接标题](这里写网址) #hashtag [[创建连接]] *斜体* - list 分点 手动设置目录 1234567891011121314目录：[标题1](#id1)[标题2](#id2)[标题3](#id3)正文内容部分：&lt;a id=&quot;id1&quot;&gt;&lt;/a&gt;content...&lt;a id=&quot;id2&quot;&gt;&lt;/a&gt;content...&lt;a id=&quot;id3&quot;&gt;&lt;/a&gt;content... 使用html标签 高亮（黄色）：&lt;mark&gt;&lt;/mark&gt; 下划线：&lt;u&gt;&lt;/u&gt; 好用插件","tags":["Obsidian"],"categories":["工具使用"]},{"title":"刷题Day01","path":"/2023/09/30/刷题Day01-1-两数之和-283-移动零-11-盛最多水的容器-15-三数之和/","content":"1.两数之和 283.移动零 11.盛最多水的容器 15.三数之和 1.两数之和分析： 用哈希表。牺牲空间换时间。时间复杂度为O(n)，空间复杂度是O(n)。 用双指针法做。双指针会用到排序，由于排序的时间复杂度为 O(nlogn)，所以整体的时间复杂度为 O(nlogn)。其次，排序后会打乱原始数组的顺序，通用的解决办法是利用一个Pair来存储value和index的对应关系，然后对Pair的value进行排序。 12345678910111213141516171819202122232425var twoSum = function(nums, target) &#123;\t// 创建一个 Pair 数组来保存元素和索引的对应关系 let pairs = nums.map((num, index) =&gt; (&#123; num, index &#125;)); // 根据元素的值对 Pair 数组进行排序 pairs.sort((a, b) =&gt; a.num - b.num); let lo = 0; let hi = nums.length - 1; while (lo &lt; hi) &#123; let sum = pairs[lo].num + pairs[hi].num; if (sum &lt; target) &#123; lo++; &#125; else if (sum &gt; target) &#123; hi--; &#125; else &#123; // 找到符合条件的元素，返回它们的索引 return [pairs[lo].index, pairs[hi].index]; &#125; &#125; // 没有找到符合条件的元素 return []; &#125;; 每日总结","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day21","path":"/2023/06/07/代码随想录算法训练营Day21-530-二叉搜索树的最小绝对差-501-二叉搜索树中的众数-236-二叉树的最近公共祖先/","content":"530.二叉搜索树的最小绝对差 501.二叉搜索树中的众数 236.二叉树的最近公共祖先 530.二叉搜索树的最小绝对差 题目： 分析：把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。 笔记： 501.二叉搜索树中的众数 题目： 分析： 笔记： 236.二叉树的最近公共祖先 题目： 分析： 笔记： 每日总结","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day20","path":"/2023/06/06/代码随想录算法训练营Day20-654-最大二叉树-617-合并二叉树-700-二叉探索树中的搜索-98-验证二叉探索树/","content":"654.最大二叉树 617.合并二叉树 700.二叉探索树中的搜索 98.验证二叉探索树 654.最大二叉树 题目：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:创建一个根节点，其值为 nums 中的最大值。递归地在最大值 左边 的 子数组前缀上 构建左子树。递归地在最大值 右边 的 子数组后缀上 构建右子树。 分析： 构造树一般采用的是前序遍历。先构造中间节点，然后递归构造左子树和右子树。 和前面104.从中序与后序遍历序列构造二叉树解题思路差不多。 617.合并二叉树 题目：给你两棵二叉树： root1 和 root2 。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 可视化 代码： 123456789101112class Solution: def mergeTrees(self, root1: TreeNode, root2: TreeNode) -&gt; TreeNode: if not root1: return root2 if not root2: return root1 root1.val += root2.val root1.left = self.mergeTrees(root1.left, root2.left) root1.right = self.mergeTrees(root1.right, root2.right) return root1 分析： 前序遍历。 此题重复使用题目给出的节点而不是创建新节点，节省时间，空间。代码里直接修改root1的节点来包含root2的节点,所以merge后的结果树其实就是root1。 700.二叉探索树中的搜索 题目：给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 笔记： 二叉搜索树是一个有序树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 二叉搜索树的 递归遍历和迭代遍历 跟普通二叉树都不一样。 98.验证二叉探索树 题目：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 分析： 笔记： 每日总结","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day18","path":"/2023/05/31/代码随想录算法训练营Day18-513-找树左下角的值-112-路径总和-113-路径总和II-106-从中序与后序遍历序列构造二叉树-105-从前序与中序遍历序列构造二叉树/","content":"513.找树左下角的值 112.路径总和 113.路径总和II 106.从中序与后序遍历序列构造二叉树 105.从前序与中序遍历序列构造二叉树 513.找树左下角的值 题目：给定一个二叉树的根节点 root，请找出该二叉树的最底层最左边节点的值。 分析： 用递归+回溯。回溯过程靠 depth += 1 和 depth -= 1 来完成。 112.路径总和 113.路径总和II 题目：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 112.可视化 分析： 用前序遍历的方法 思路是把 targetsum 用 count 计数，从根节点开始递归往下减，看到最后的叶子节点值是否为0。如果为0，再递归回去为给定的targetsum。 106.从中序与后序遍历序列构造二叉树 105.从前序与中序遍历序列构造二叉树 题目：给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 分析： 笔记： 前序和中序可以唯一确定一棵二叉树。后序和中序可以唯一确定一棵二叉树。前序和后序不可以唯一确定一棵二叉树 每日总结 昨天以为懂了，今天一看又不懂了，每天就是似懂非懂。命运之花的最后一瓣到底会是懂还是不懂呢。。 天大的好消息，得知了python tutor这个网站，终于可以清楚地知道递归是怎么运行的了，感恩。","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day17","path":"/2023/05/29/代码随想录算法训练营Day17-110-平衡为叉树-257-二叉树的所有路径-404-左叶子之和/","content":"110.平衡为叉树 257.二叉树的所有路径 404.左叶子之和 110.平衡为叉树 题目：给定一个二叉树，判断它是否是高度平衡的二叉树。 123456789101112131415161718192021222324252627class Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if self.get_height(root) != -1: return True else: return False def get_height(self,root): if not root: return 0 #左 left_height = self.get_height(root.left) if left_height == -1: return -1 #右 right_height = self.get_height(root.right) if right_height == -1: return -1 #中 if abs(left_height - right_height) &gt; 1: return -1 else: return 1 + max(left_height , right_height) 注：当发现某个子树不平衡时，会返回-1作为一个标记，而不是实际的高度值。 笔记： 求高度用后序遍历，求深度用前序遍历。 257.二叉树的所有路径 题目：给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 分析： 用到了回溯的方法 前序遍历 递归函数参数： node：当前节点，表示当前递归的节点。 path：路径列表，用于存储从根节点到当前节点的路径。 result：结果列表，用于存储所有根节点到叶子节点的路径。 递归终止条件：如果当前节点为空，即 node 为 None，表示递归到了空节点，此时直接返回，结束递归。 404.左叶子之和 题目：计算给定二叉树的所有左叶子之和。 分析： 后序遍历 本题要先检查根节点的左子节点是否为叶节点（必须要通过节点的父节点来判断其左孩子是不是左叶子）if root.left and not root.left.left and not root.left.right 每日总结有点搞懂了，递归的代码，但还是不能靠自己写出来，需要整合一下。","categories":["刷题记录"]},{"title":"代码随想录算法训练营D16","path":"/2023/05/27/代码随想录算法训练营D16-104-二叉树的最大深度-111-二叉树的最小深度-222-完全二叉树的节点个数/","content":"104.二叉树的最大深度 111.二叉树的最小深度 222.完全二叉树的节点个数 104.二叉树的最大深度 题目：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 pythontutor可视化 分析： 区分二叉树的高度和深度：本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。 本题用后序遍历的方法来解题。 笔记： 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始） 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始） 111.二叉树的最小深度 题目：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。 分析： 本题依然是前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。 笔记： 222.完全二叉树的节点个数 题目：给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 答案代码：注：这种计算方式假设二叉树是完全二叉树（除了最后一层外，其余层的节点都是满的）。对于非完全二叉树或者缺失节点的情况，这种计算方式可能不适用。 1234567891011121314151617class Solution: def countNodes(self, root: TreeNode) -&gt; int: if not root: return 0 left = root.left right = root.right leftDepth = 0 #这里初始为0是有目的的，为了下面求指数方便 rightDepth = 0 while left: #求左子树深度 left = left.left leftDepth += 1 while right: #求右子树深度 right = right.right rightDepth += 1 if leftDepth == rightDepth: return (2 &lt;&lt; leftDepth) - 1 #注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0 return self.countNodes(root.left) + self.countNodes(root.right) + 1 纠错： 最后一句我写成leftDepth + rightDepth + 1，显然是错的，没搞懂原理…最后一句代码作用是 递归地向下遍历左子树和右子树，直到叶子节点。 笔记： 满二叉树节点数量 &#x3D; (2**depth) - 1 每日总结实话实说，这几个题目做了好几天了。递归的思想，真的好难搞懂啊，就这么摆烂了几天…","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day15","path":"/2023/05/26/代码随想录算法训练营Day15-层序遍历-226-翻转二叉树-101-对称二叉树/","content":"层序遍历 226.翻转二叉树 101.对称二叉树 层序遍历 二叉树的层序遍历 题目：给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。 分析： #利用长度法 root 是二叉树的根节点。queue 是用于进行层序遍历的队列。level 则是用于存储每一层节点值的列表。再将 level 添加到 result 列表中。这样就可以在 result 列表中保存每一层的节点值。 #递归法 笔记： 二叉树的层序遍历也称为广度优先搜索（BFS），是一种遍历树结构的方法。 226.翻转二叉树 题目：给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 分析：递归法：前序遍历 递归法 前序遍历(中前后)：”前序遍历” 是指在遍历树时首先访问根节点，然后遍历左子树，最后遍历右子树。 101.对称二叉树 题目：给你一个二叉树的根节点 root ， 检查它是否轴对称。 分析： 首先想清楚，判断对称二叉树要比较的是哪两个节点？—&gt; 要比较的是两个树（这两个树是根节点的左右子树），比较的是两个子树的里侧和外侧的元素是否相等。 每日总结","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day14","path":"/2023/05/25/代码随想录算法训练营Day14-二叉树-理论基础、递归遍历、迭代遍历、统一迭代/","content":"二叉树 理论基础、递归遍历、迭代遍历、统一迭代 理论基础笔记： 二叉树有几种特殊的形式： 满二叉树：每个节点要么是叶节点（没有子节点），要么有两个子节点。 完全二叉树：所有层级都完全填满，除了最后一层，最后一层的所有节点都尽可能地集中在左边。 平衡二叉树：每个节点的两个子树的高度差最多为1。 二叉搜索树 —&gt; 平衡二叉搜索树 二叉树的存储方式：可以链式存储（指针），也可以顺序存储（数组）。 二叉树的遍历方式： 深度优先遍历 前序遍历（递归法，迭代法）:中左右 中序遍历（递归法，迭代法）:左中右 后序遍历（递归法，迭代法）：左右中 广度优先遍历 层次遍历（迭代法） 递归遍历笔记： 三要素：确定递归函数的参数和返回值、确定终止条件、确定单层递归的逻辑。 1234567891011121314151617181920212223242526272829303132# 前序遍历class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] left = self.preorderTraversal(root.left) right = self.preorderTraversal(root.right) return [root.val] + left + right# 中序遍历class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: if root is None: return [] left = self.inorderTraversal(root.left) right = self.inorderTraversal(root.right) return left + [root.val] + right# 后序遍历class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] left = self.postorderTraversal(root.left) right = self.postorderTraversal(root.right) return left + right + [root.val] 迭代遍历笔记： 统一迭代笔记： 每日总结迭代法先跳过，后面回来补。话说前面还漏了好几道题没做呢，学半天不知道在学啥，一团浆糊，知识用不上去啊…","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day13","path":"/2023/05/23/代码随想录算法训练营DAy13-239-滑动窗口最大值-347-前K个高频元素/","content":"239.滑动窗口最大值 347.前K个高频元素 239.滑动窗口最大值 题目：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。 分析： 笔记： 347.前K个高频元素 题目：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。 答案思路： 统计元素出现频率 （用map）对频率排序 （用优先级队列）找出前K个高频元素 要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。 笔记： 实现优先级队列的常见方法是使用堆（Heap）数据结构。堆是一种具有特殊性质的二叉树，称为二叉堆。在二叉堆中，每个节点的值都大于或等于其子节点的值（大顶堆），或者每个节点的值都小于或等于其子节点的值（小顶堆）。 每日总结滑动窗口最大值看了好几遍代码还是捋不明白，接下来再多看看吧。","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day11","path":"/2023/05/22/代码随想录算法训练营Day11-20-有效的括号-1047-删除字符串中的所有相邻重复项-150-逆波兰表达式求值/","content":"20.有效的括号 1047.删除字符串中的所有相邻重复项 150.逆波兰表达式求值 20.有效的括号 题目：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 思路： 如果当前字符是一个左括号，那么将其对应的右括号添加到栈中。如果当前字符是一个右括号，那么检查栈是否为空或者栈顶的括号是否与当前字符不匹配。 笔记： pop() 是一个方法，它会移除栈顶的元素。 1047.删除字符串中的所有相邻重复项 题目：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 分析： 通过遍历字符串，使用一个栈来记录当前处理过的字符，当遇到与栈顶元素相同的字符时，将栈顶元素弹出。 注释：这题就了解了栈的方法，双指针法回头补。 150.逆波兰表达式求值 题目：给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 分析： 遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。 每日总结每天效率很低，明天开始改进一下。","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day10","path":"/2023/05/21/代码随想录算法训练营Day10-232-用栈实现队列-225-用队列实现栈/","content":"232.用栈实现队列 225.用队列实现栈 栈与队列理论基础 栈是一个后进先出（Last In First Out，简称 LIFO）的数据结构。这意味着最后一个添加到栈中的元素总是第一个被移除的。想象叠盘子。 队列是一个先进先出（First In First Out，简称 FIFO）的数据结构。这意味着第一个添加到队列的元素总是第一个被移除的。想象一个管道。 在 Python 中，可以使用列表（List）来实现栈的功能;使用 deque 来实现队列功能。 232.用栈实现队列 题目：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）push(x) -- 将元素 x 添加到队列的末尾pop() -- 从队列首部移除并返回元素peek() -- 返回队列首部的元素empty() -- 检查队列是否为空 分析： 用两个栈实现队列。 笔记： self.stack_out 中元素的顺序是队列的顺序. 225.用队列实现栈 题目：请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空 分析： 用一个队列就可以实现栈。 笔记： deque 是 Python 的一个内置模块，名字来源于 “double-ended queue”（双端队列）。它提供了一种数据结构，即可以从两端添加或移除元素。 12345678910111213141516from collections import deque# 创建一个 dequed = deque()# 从右侧添加元素d.append(&#x27;a&#x27;) # deque([&#x27;a&#x27;])# 从左侧添加元素d.appendleft(&#x27;b&#x27;) # deque([&#x27;b&#x27;, &#x27;a&#x27;])# 从右侧移除元素d.pop() # &#x27;a&#x27;, deque([&#x27;b&#x27;])# 从左侧移除元素d.popleft() # &#x27;b&#x27;, deque([]) 由于栈的特性（后进先出），我们必须让元素在添加和移除时都从队列的同一端进行，这样最后添加的元素才会第一个被取出。 栈（Stack）可以被比作一个瓶子，你可以在顶部添加物品（入栈或者 push），也只能从顶部移除物品（出栈或者 pop）；队列（Queue）则可以被比作一个管道。你可以从管道的一端添加物品（入队或者 enqueue），然后物品会按照被添加的顺序从另一端移出（出队或者 dequeue）。 每日总结总算是比较轻松的一天了，没有复杂的代码（幸福中带点心酸）。","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day09","path":"/2023/05/20/代码随想录算法训练营Day09-28-实现strStr-459-重复的子字符串/","content":"28.实现strStr() 459.重复的子字符串 28.实现strStr() 题目：给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 分析： 笔记： 459.重复的子字符串 题目：给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 分析： 每日总结","tags":["KMP"],"categories":["刷题记录"]},{"title":"代码随想录算法训练营Day08","path":"/2023/05/19/344-反转字符串-541-反转字符串II-剑指Offer05-替换空格-151-翻转字符串里的词-剑指Offer58-II-左旋转字符串/","content":"344.反转字符串 541.反转字符串II 剑指Offer05.替换空格 151.翻转字符串里的词 剑指Offer58-II.左旋转字符串 344.反转字符串 题目：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 分析： 与反转链表一样，使用双指针法。反转字符串比反转链表还要简单一些。 但是反转链表使用迭代法的双指针，而反转字符串使用左右指针，原因：它们的底层数据结构不同 字符串可以视为一个字符数组，可以直接通过索引来访问数组的任意位置。 链表是线性存储结构，没有索引，我们不能随机访问链表的任意位置，只能从头部一次遍历到尾部。 541.反转字符串II 题目：给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转；如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 分析： 要用到切片操作。 要把字符串转换成列表数组：为了能够修改字符串中的字符，因为在python中，字符串是不可变的。 笔记：join() 是字符串的一个方法：调用形式：str.join(iterable) str 是连接符，iterable 是可迭代对象例如，如果 res = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]，那么 &#39;&#39;.join(res) 会返回 &#39;abc&#39;。 剑指Offer05.替换空格 题目：请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 自己尝试写的：这种写法 时间复杂度和空间复杂度都为O(n) 12345678class Solution(object): def replaceSpace(self, s): res = list(s) n = len(s) for i in range(n): if res[i] == &#x27; &#x27;: res[i] = &#x27;%20&#x27; return &#x27;&#x27;.join(res) 答案思路： 这个问题的核心在于要在原地（不使用额外的空间）替换字符串中的所有空格为 “%20”。 首先根据空格的数量扩展列表的大小，然后用双指针从后向前替换空格为 “%20”。这种方式可以避免在列表中创建额外的字符串对象，所以在内存使用上更为高效。 笔记： Python 列表的切片操作是左闭右开的。 151.翻转字符串里的词 题目：给你一个字符串 s ，请你反转字符串中单词的顺序。 分析：要求：不要使用辅助空间，空间复杂度要求为O(1)步骤：1.去除多余的空格2.翻转字符数组3.翻转每个单词4.翻转字符串里的单词 剑指Offer58-II.左旋转字符串 题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 每日总结反转字符串II想半天还是想不出来，看答案了，进展为零。最后一题还没做，之后补。","tags":["双指针"],"categories":["刷题记录"]},{"title":"代码随想录算法训练营Day07","path":"/2023/05/18/代码随想录算法训练营Day07-454-四数相加II-383-赎金信-15-三数之和-18-四数之和/","content":"454.四数相加II 383.赎金信 15.三数之和 18.四数之和 454.四数相加II 题目：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：0 &lt;&#x3D; i, j, k, l &lt; nnums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0 分析：[chatgpt]第一反应可能是暴力解法，也就是通过四重for循环来遍历。但是这种方法的时间复杂度太高（O(n^4)），不适合处理大规模数据。 为了提高效率，可以考虑使用哈希表来存储某些中间结果。先遍历 nums1 和 nums2，计算所有可能的两数之和，然后将这个和以及它出现的次数存储到哈希表中。这样，哈希表的键就是两数之和，对应的值就是这个和出现的次数。 然后再遍历 nums3 和 nums4，对于每一对数，计算它们的和的负值，然后在哈希表中查找这个负值。如果找到了，那么说明存在满足条件的四元组，而哈希表中对应的值就是这些四元组的数量。 383.赎金信 题目：给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。 分析：此题和 242.有效的字母异位词 思路相同。 笔记： collections.defaultdict 是 Python 的一个内置字典子类，它重载了一种特殊的方法，使得如果你试图访问或修改一个不存在的键（key）对应的值（value），这个字典会首先用一个默认的值类型来创建这个键。 15.三数之和 题目：给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。 分析： 这道题和前面的四数相加II不同点在于，它不可以包含重复的三元组，如果用同样的哈希法计算，再去重，很容易超时。 此题用排序 + 双指针法。 排序的目的是便于进行双指针搜索，并进行重复元素的剪枝。 18.四数之和 题目：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）。 分析： 使用排序 + 双指针法。基本解法就是在 15.三数之和 的基础上再套一层for循环。 三数之和与四数之和解题差异: 在三数之和问题中，我们只需要确定一个数字,如 nums[i],然后在剩余的数组中使用双指针（left 和 right）来找到满足条件的二元组。在确定一个数字后，问题就被降低为了二数之和问题。 在四数之和问题中，我们需要确定两个数字（如 nums[i] 和 nums[k]），然后在剩余的数组中使用双指针（p 和 q）来找到满足条件的二元组。在确定两个数字后，问题就被降低为了二数之和问题。 每日总结无。","tags":["双指针法","哈希法"],"categories":["刷题记录"]},{"title":"代码随想算法训练营Day05","path":"/2023/05/17/代码随想算法训练营Day05-242-有效得字母异位词-349-两个数组的交集-202-快乐数-1-两数之和/","content":"242.有效得字母异位词 349.两个数组的交集 202.快乐数 1.两数之和 242.有效得字母异位词 题目：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 分析： 此题用数组作为哈希表来解。还有更简单的方式，如使用defaultdict或Counter。 笔记： 字符a到字符z的ASCII是26个连续的数值。 比较： 数组作为哈希表： 使用条件： 已知值的范围：如果知道将要存储的值或键的范围是有限的且不会过大，那么可以使用数组作为哈希表。 整数键：如果键是整数或者可以被映射到整数（比如字符），并且这些整数的范围相对较小，那么可以使用数组作为哈希表。 优点： 访问速度快：在知道索引的情况下，可以在 O(1) 时间内访问任何元素。 内存效率：如果键是连续的或者接近连续的整数，数组会比其他类型的哈希表更内存高效。 缺点： 空间浪费：如果键的范围非常大或者不连续，使用数组可能会导致大量的内存浪费。不支持非整数键：对于非整数键，需要额外的映射步骤才能使用数组。 集合（set）： 使用条件： 值的唯一性：如果需要存储的数据需要保持唯一性，那么可以使用集合。 查找操作频繁：如果需要频繁地查找某个元素是否存在，那么可以使用集合。 优点： 值的唯一性：集合中的元素都是唯一的，不会出现重复的元素。 查找速度快：集合的实现通常是基于哈希表的，所以查找速度非常快，接近 O(1)。 缺点： 空间使用：由于集合需要额外的空间来存储哈希表，所以其空间使用效率通常低于数组。 不保持元素的插入顺序：在 Python 的 set 类型中，元素的存储并不保持插入的顺序。 349.两个数组的交集 题目：给定两个数组 nums1 和 nums2 ，返回它们的交集。输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 代码：set方法 1234567891011class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: nums_set = set(nums1) # 使用Python的set数据结构将nums1去重 result_set = set() # 创建一个空的set来存放结果 for num in nums2: # 如果nums2中的元素在nums_set中出现过 if num in nums_set: result_set.add(num) # 将这个元素添加到结果集中 return list(result_set) # 将结果集转换为列表并返回 202.快乐数 题目：编写一个算法来判断一个数 n 是不是快乐数。快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为 1，那么这个数就是快乐数。 笔记：set 是一种数据类型，它代表一个无序的、元素唯一的集合。set 的一个重要特性是它会自动去除重复元素。 1.两数之和 题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 分析： 什么时候使用哈希法？当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。 本题用map：因为需要使用 key value结构来存放，key来存元素，value来存下标。 每日总结每天花太久时间了，完全没基础学起来好累。","categories":["刷题记录"]},{"title":"代码随想录算法训练营Day04","path":"/2023/05/16/代码随想录算法训练营Day04-24-两两交换链表中的节点-19-删除链表的倒数-第N个节点-面试题02-07-链表相交-142-环形链表II/","content":"24.两两交换链表中的节点 19.删除链表的倒数第N个节点 面试题02.07.链表相交 142.环形链表II 24.两两交换链表中的节点 题目：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即只能进行节点交换）。 分析： 用虚拟头节点。 在链表中，我们不能直接交换两个节点，而需要通过改变它们的next指针来实现。 这道题用pre、cur、post来表示左、中间、右三个相邻节点：1pre -&gt; cur -&gt; post -&gt; ... 要实现交换节点，通过改变它们的next指针 第一步：cur.next &#x3D; post.next这一行将cur的next指针指向了post的下一个节点。 1234pre -&gt; cur -&gt; ... (post的后续部分) | V post -&gt; ... 第二步：post.next &#x3D; cur这一行将post的next指针指向了cur。 1234pre -&gt; cur -&gt; ... (post的后续部分) ^ | post 第三步：pre.next &#x3D; post这一行将pre的next指针指向了post。 1pre -&gt; post -&gt; cur -&gt; ... (post的后续部分) 笔记： 要注意 cur &#x3D; post.next 和 cur.next &#x3D; post.next 是不同的。cur.next &#x3D; post.next，会更改 cur 节点的下一个节点，使得cur指向了next，从而断开了cur和post之间的链接。cur &#x3D; post.next ，cur 和 post 之间的链接依然存在，pre依然连接到cur。 19.删除链表的倒数 题目：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 分析： 虚拟头节点、快慢双指针 这个方法之所以能够找到倒数第 n 个节点，是因为当 fast 指针走到链表末尾时，slow 指针正好走到倒数第 n+1 个节点。因为 fast 指针比 slow 指针多走了 n+1 步，所以 fast 指针到达末尾时，slow 指针离末尾还有 n 步，即 slow 指针指向的是倒数第 n+1 个节点。 面试题02.07.链表相交 题目：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 分析： 目的是求两个链表交点节点的指针。 思路：先计算出两个链表的长度，然后让两个指针从同一起点（末尾对齐的地方）开始移动，直到找到交点或者到达链表的末尾。 解释：两个链表如果有交点，那么从交点开始，到链表结束，它们都是一样的。这就是说，如果有两个指针，分别从两个链表的交点开始同步前进，那么这两个指针一定是同时到达链表的末尾的。所以目标就是让两个指针能够同时到达链表的末尾。 142.环形链表II 题目：给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 分析： 每日总结","tags":["双指针"],"categories":["刷题记录"]},{"title":"代码随想录算法训练营Day03","path":"/2023/05/15/代码随想录算法训练营Day03-203-移除链表元素-707-设计链表-206-反转链表/","content":"203.移除链表元素 707.设计链表 206.反转链表 203.移除链表元素 题目：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回新的头节点。 分析： 首先判断删除的是什么节点，是头结点还是其他节点。 笔记： 链表类型： 单链表：单链表中的指针域只能指向节点的下一个节点。 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。既可以向前查询也可以向后查询。 循环链表：链表首尾相连。 如果要删除头节点，有这两种方式： 直接使用原来的链表来进行删除操作: 将头节点向后移动一位 , head &#x3D; head next 设置一个虚拟头节点在进行删除操作 （统一的方法，即既头节点和其他节点都适用） ListNode是一个用户定义的数据类型，用于表示链表中的节点。它有两个属性：val和next。val用于存储节点的值，而next则是一个指向下一个节点的指针。如果在创建新的ListNode时没有提供val和next，它们会默认被设置为0和None。 707.设计链表 题目：你可以选择使用单链表或者双链表，设计并实现自己的链表。 206.反转链表 题目：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 分析：反转链表的主要思路是遍历链表，同时改变每个节点的next指针，使其指向前一个节点而不是下一个节点。 笔记： 有两种解决方法，分别是双指针法和递归法 双指针法：使用了两个指针，pre 和 cur， pre 指针始终在 cur 指针的前面。关键点在于，需要在改变当前节点cur的next指针之前先保存cur的下一个节点，因为改变next指针后，我们将无法再访问到原来的下一个节点。 递归法： 每日总结还在摸索中，每天就是背一遍代码…笔记内容还有不完善的地方，之后遇到相同知识点再回来补充。","tags":["双指针法"],"categories":["刷题记录"]},{"title":"代码随想录算法训练营Day02","path":"/2023/05/11/代码随想录算法训练营Day02-977-有序数组的平方-209-长度最小的子数组-59-螺旋矩阵/","content":"977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵|| 977.有序数组的平方 题目：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 分析： 可以用暴力排序法，但是时间复杂度为O(nlogn)。而用双指针法，时间复杂度为O(n) 。 此题为左右指针，两个指针 i 和 j 分别指向 nums 列表的开始和结束。因为最大值会出现在开始或结尾。 笔记： 双指针应用：快慢指针：从同一位置开始，一个快一点，一个慢一点。用于解决例如判断链表是否存在环、找到链表的中间节点等问题。左右指针：从两头开始，向中间靠拢。用于二分查找、两数之和、反转数组、回文串判断。 209.长度最小的子数组 题目：给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1,numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 分析： 暴力法用两个for循环分别遍历区间的起始和终止位置，从而完成一个不断搜索区间的过程；滑动窗口法相当于用一个for循环达到暴力法的效果。 代码答案： 123456789101112class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: res = float(&quot;inf&quot;) # 定义一个无限大的数 Sum = 0 # 滑动窗口数值之和 i = 0 # 滑动窗口起始位置 for j in range(len(nums)): Sum += nums[j] while Sum &gt;= s: res = min(res, j-i+1) Sum -= nums[i] i += 1 return 0 if res == float(&quot;inf&quot;) else res 笔记： res &#x3D; float(‘inf’) 是用来初始化 res 的，表示无穷大。这是一个常见的编程技巧，当我们需要找到一些最小值的时候，我们通常会先将变量设置为一个非常大的数。 59.螺旋矩阵||代码思路：初始化矩阵–&gt; 设定起始点和中心点 –&gt; 按层填充矩阵 –&gt; 处理中心点 –&gt; 返回结果 将矩阵看作由一层层的 “环” 组成，然后按层填充这些 “环”，每层按照 “从左到右、从上到下、从右到左、从下到上” 的顺序填充。 笔记： 要写出正确的二分法一定要坚持循环不变量原则：在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。做螺旋矩阵题目时同样要遵循这个原则。 每日总结今天花了好几个小时，主要把时间用在了解算法上了，代码部分直接是照着抄了一遍。做了双指针、滑动窗口的用法笔记，有些是chatgpt提供的，有些参考了labuladong的算法小抄网站。博客是不久前搭建的，每天优化一点点，希望训练营结束后这个博客界面能像样点。","tags":["双指针","滑动窗口"],"categories":["刷题记录"]},{"title":"代码随想录算法训练营Day01","path":"/2023/05/10/704-二分查找-27-移除元素/","content":"704.二分查找 27.移除元素 704.二分查找 题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 思路：无，直接看答案了。 代码：在力扣里写了左闭右闭区间的版本，这里粘贴上左闭右开的版本。目前自己写不出来，只能靠模仿重复。训练营答案： 1234567891011121314class Solution: def search(self,nums: List[int],target: int) -&gt; int: left, right = 0, len(nums) while left &lt; right: middle = left + (right - left) // 2 if nums[middle] &gt; target: right = middle elif nums[middle] &lt; target: left = middle + 1 else: return middle # 数组中找到目标值，直接返回下标 return -1 # 未找到目标值 笔记： 二分法前提条件：有序数组、无重复元素 二分法要注意两种写法，分别是：左闭右闭、左闭右开 middle公式：middle = left + (right - left) // 2 ，这样写有助于防止整型溢出，而不是用这种写法(left + right) &#x2F;&#x2F; 2。 左闭右闭区间 [left, right]：left, right = 0, len(nums) - 1while (left &lt;= right)left = middle+1 和 right = middle-1 左闭右开区间 [left, right)：left, right = 0, len(nums)while (left &lt; right)left = middle + 1 和 right = middle 27.移除元素 题目：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 思路：啥都不懂，编辑出了以下这段。理所当然觉得把元素删掉就好了… 123456789class Solution(object): def removeElement(self, nums, val): i = 0 while i &lt; len(nums): if nums[i] == val: del nums[i] else: i += 1 print(len(nums),nums) 训练营答案： 双指针 12345678910111213class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: # 快慢指针 fast = 0 # 快指针 slow = 0 # 慢指针 size = len(nums) while fast &lt; size: # 不加等于是因为，a = size 时，nums[a] 会越界 # slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，则把它与 slow 替换 if nums[fast] != val: nums[slow] = nums[fast] slow += 1 fast += 1 return slow 笔记： 数组理论基础：数组的元素在内存地址中是连续的,数组中的元素不能删除，只能覆盖，且物理空间没有改变。 每日总结今天是参加训练营的第一天，连python都是不久前才开始自学的（虽然之前上过一学期的课，但是非常基础），更不用说接触算法了。以乌龟爬行般的速度大致了解了自己正在学习以及即将要学的东西的概念后，我还是下决心逼自己一把。60天时间，不奢望自己能跑起来，也很可能走不起来，但起码要站起来吧！！！","tags":["二分法","双指针"],"categories":["刷题记录"]},{"title":"连体形","path":"/wiki/日语/连体形.html","content":"连体形可以理解为动词的各种形式的简体形。 动词的各种形式的简体形 【一般时态肯定】的简体形：辞书形&#x2F;原形【一般时态否定】的简体形：ない形【过去时肯定】的简体形：た形【过去时否定】的简体形：~なかった（变形规则：「ない」形去「い」加上「かった」） 连体形后面接体言 连体形一般指动词直接修饰名词的形式。 例子：作る料理（制作的料理）、買ったCD（买的CD） 体言：名词、数量词、代词 复合形作为连体形使用 除了上面的独立活用形外，还有一些复合形动词，用于修饰名词。例如：ている（て形+いる） —&gt; 食べている人（正在吃饭的人） 、住んでいる町（居住的城市）"},{"title":"连用形","path":"/wiki/日语/连用形.html","content":"连用形可以理解为动词的ます形 去掉「ます」之后剩下的部分。后续用 「V-ます」 表示 连用形后面接用言 用言：动词、形容词、形容动词"},{"title":"常用接续方式","path":"/wiki/日语/接续.html","content":"接续（接続）在日语中，是指将动词、形容词、名词等词汇按照一定的形式连接起来，从而使句子表达完整的意思。通过不同的接续形式表达动作顺序、愿望、请求、否定、假设条件等丰富的含义。 动词接续动词接续的核心在于动词的活用形。 活用形举例 「て形」用于连接多个动作、表示顺序、原因、状态等。 「ます形」用于表达礼貌语气。 「ない形」主要用于表达否定、否定请求或条件句中的否定。 「た形」用于表达过去时或假设条件。 常见用法 接续形 示例 说明 V−て + いる 食べている 表示动作的持续状态 V-て + ください 食べてください 请求（请做某事） V−ます 行きます 表达礼貌的动作 V-ます　+ たい 会いたい 表示想做某事的愿望 V-ない + でください 行かないでください 表示否定请求（请不要做） V−ない + といけない 行かないといけない 表示义务（必须去……） V−た + ことがある 行ったことがある 表示经验（曾经……过） V−た + ほうがいい 行ったほうがいい 表示建议（最好去……） V−たら 行ったら 表示假设条件（如果……的话） 注：【V-ます】表示【动词ます形去掉ます】 い形容词接续い形容词的接续主要通过改变词尾的「い」来连接其他词或表达否定、过去等含义。 な形容词接续名词接续"},{"title":"判断、评价","path":"/wiki/日语/n2_1-1.html","content":"~はずだ接続：连体形、名词+の 含义：应该。表示合理的推测或预期，有把握的推测，通常语气比较肯定 例句：会議は　２時に始まるはずです。(会议应该在2点开始) ~はずがない~わけだ~わけがない"}]